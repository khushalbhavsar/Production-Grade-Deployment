pipeline {
    agent any
    
    environment {
        // Docker Configuration
        DOCKER_REGISTRY = 'docker.io'
        DOCKER_IMAGE = 'khushalbhavsar/multibranch-flask-app'
        DOCKER_CREDENTIALS_ID = 'docker-hub-credentials'
        
        // Application Configuration
        APP_NAME = 'shopeasy'
        APP_PORT = '5000'
        
        // Kubernetes Configuration
        KUBECONFIG_CREDENTIALS_ID = 'kubeconfig'
        K8S_NAMESPACE = 'default'
        
        // Build Information
        BUILD_TAG = "${env.BUILD_NUMBER}-${env.GIT_COMMIT?.take(7) ?: 'latest'}"
    }
    
    options {
        buildDiscarder(logRotator(numToKeepStr: '10'))
        timestamps()
        timeout(time: 30, unit: 'MINUTES')
        disableConcurrentBuilds()
    }
    
    stages {
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    env.GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    // Use GIT_BRANCH from Jenkins SCM, fallback to git command
                    def branchName = env.GIT_BRANCH ?: sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                    // Remove 'origin/' prefix if present
                    env.GIT_BRANCH_NAME = branchName.replaceAll('origin/', '')
                    // Set BRANCH_NAME for 'when { branch }' conditions in non-multibranch pipelines
                    env.BRANCH_NAME = env.GIT_BRANCH_NAME
                    echo "Building branch: ${env.BRANCH_NAME}, commit: ${env.GIT_COMMIT_SHORT}"
                }
            }
        }
        
        stage('Setup Python Environment') {
            steps {
                sh '''
                    python3 -m venv venv
                    . venv/bin/activate
                    pip install --upgrade pip
                    pip install -r src/requirements.txt
                '''
            }
        }
        
        stage('Code Quality') {
            parallel {
                stage('Lint') {
                    steps {
                        sh '''
                            . venv/bin/activate
                            pip install flake8 pylint
                            flake8 src/ --max-line-length=120 --exclude=venv || true
                            pylint src/app.py --disable=C0114,C0115,C0116 --max-line-length=120 || true
                        '''
                    }
                }
                
                stage('Security Scan') {
                    steps {
                        sh '''
                            . venv/bin/activate
                            pip install bandit safety
                            bandit -r src/ -ll || true
                            safety check -r src/requirements.txt || true
                        '''
                    }
                }
            }
        }
        
        stage('Unit Tests') {
            steps {
                sh '''
                    . venv/bin/activate
                    pip install pytest pytest-cov pytest-html
                    pytest tests/ -v --cov=src --cov-report=xml --cov-report=html --junitxml=test-results.xml
                '''
            }
            post {
                always {
                    junit allowEmptyResults: true, testResults: 'test-results.xml'
                    publishHTML(target: [
                        allowMissing: true,
                        alwaysLinkToLastBuild: true,
                        keepAll: true,
                        reportDir: 'htmlcov',
                        reportFiles: 'index.html',
                        reportName: 'Coverage Report'
                    ])
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                script {
                    docker.build("${DOCKER_IMAGE}:${BUILD_TAG}", "-f docker/Dockerfile .")
                    docker.build("${DOCKER_IMAGE}:latest", "-f docker/Dockerfile .")
                }
            }
        }
        
        stage('Test Docker Image') {
            steps {
                script {
                    // Run container and test health endpoint
                    sh """
                        docker run -d --name test-${APP_NAME}-${BUILD_NUMBER} -p 5001:5000 ${DOCKER_IMAGE}:${BUILD_TAG}
                        sleep 10
                        curl -f http://localhost:5001/health || (docker logs test-${APP_NAME}-${BUILD_NUMBER} && exit 1)
                        docker stop test-${APP_NAME}-${BUILD_NUMBER}
                        docker rm test-${APP_NAME}-${BUILD_NUMBER}
                    """
                }
            }
            post {
                failure {
                    sh "docker rm -f test-${APP_NAME}-${BUILD_NUMBER} || true"
                }
            }
        }
        
        stage('Push Docker Image') {
            when {
                expression { env.BRANCH_NAME == 'main' || env.BRANCH_NAME == 'develop' }
            }
            steps {
                script {
                    docker.withRegistry("https://${DOCKER_REGISTRY}", DOCKER_CREDENTIALS_ID) {
                        docker.image("${DOCKER_IMAGE}:${BUILD_TAG}").push()
                        docker.image("${DOCKER_IMAGE}:latest").push()
                        
                        // Tag with branch name
                        docker.image("${DOCKER_IMAGE}:${BUILD_TAG}").push("${env.GIT_BRANCH_NAME}")
                    }
                }
            }
        }
        
        stage('Deploy to Kubernetes') {
            when {
                expression { env.BRANCH_NAME == 'main' }
            }
            steps {
                withCredentials([file(credentialsId: KUBECONFIG_CREDENTIALS_ID, variable: 'KUBECONFIG')]) {
                    sh """
                        # Update image tag in deployment
                        sed -i 's|image:.*|image: ${DOCKER_IMAGE}:${BUILD_TAG}|g' k8s/deployment.yaml
                        
                        # Apply Kubernetes manifests
                        kubectl apply -f k8s/deployment.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f k8s/service.yaml -n ${K8S_NAMESPACE}
                        kubectl apply -f k8s/ingress.yaml -n ${K8S_NAMESPACE}
                        
                        # Wait for rollout
                        kubectl rollout status deployment/${APP_NAME}-app -n ${K8S_NAMESPACE} --timeout=300s
                    """
                }
            }
        }
        
        stage('Integration Tests') {
            when {
                expression { env.BRANCH_NAME == 'main' }
            }
            steps {
                withCredentials([file(credentialsId: KUBECONFIG_CREDENTIALS_ID, variable: 'KUBECONFIG')]) {
                    sh """
                        # Get service endpoint
                        SERVICE_IP=\$(kubectl get svc ${APP_NAME}-service -n ${K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "pending")
                        
                        if [ "\$SERVICE_IP" != "pending" ]; then
                            echo "Testing deployed application at \$SERVICE_IP"
                            curl -f http://\$SERVICE_IP:5000/health || true
                        else
                            echo "LoadBalancer IP not yet assigned, skipping integration test"
                        fi
                    """
                }
            }
        }
    }
    
    post {
        always {
            // Clean up Docker images to save space
            sh """
                docker rmi ${DOCKER_IMAGE}:${BUILD_TAG} || true
                docker rmi ${DOCKER_IMAGE}:latest || true
            """
            
            // Clean workspace
            cleanWs()
        }
        
        success {
            echo "‚úÖ Pipeline completed successfully!"
            script {
                if (env.GIT_BRANCH_NAME == 'main') {
                    echo "üöÄ Application deployed to production!"
                }
            }
        }
        
        failure {
            echo "‚ùå Pipeline failed!"
            // Uncomment to enable email notifications
            // emailext (
            //     subject: "Pipeline Failed: ${env.JOB_NAME} [${env.BUILD_NUMBER}]",
            //     body: "Check console output at ${env.BUILD_URL}",
            //     recipientProviders: [[$class: 'DevelopersRecipientProvider']]
            // )
        }
        
        unstable {
            echo "‚ö†Ô∏è Pipeline completed with warnings"
        }
    }
}
